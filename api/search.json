[{"id":"4122a09df2e4f3d18921791a0dcc0507","title":"docker","content":"Docker仅记录分享部分常用，更多请见Docker官方文档\ndocker安装Centos 7卸载docker旧版本\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-selinux docker-engine-selinux docker-engine\n\n安装相关工具类\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\n配置docker仓库\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\naliyun的源\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n安装docker\nyum install docker-ce\n\n检验docker安装成功，成功展示出版本号即成功\ndocker -v\n\n启动docker\nsystemctl start docker\n\n验证docker\ndocker run hello-world\n\n\n设置开机自启\nchkconfig docker on\n\n升级docker ce\nyum -y upgrade\n\n卸载docker ce \nyum remove docker-ce\nrm -rf /var/lib/docker\n\n\n\n配置163镜像与存储目录（更快速）\nvim /etc/docker/daemon.json\n\nregistry-mirrors 为镜像地址\ndocker 版本&lt;20 graph 为存储目录 建议不要使用默认的 否则空间会不够用\ndocker 版本&gt;20 graph已经弃用 需使用 data-root\n&#123;\n  \"registry-mirrors\": [\"http://hub-mirror.c.163.com\"],\n  \"data-root\": \"/home/docker\"\n&#125;\n\n配置完成后重启\nsystemctl daemon-reload\nsystemctl restart docker\n\n\n\nWindows下载docker-desktop即可\ndocker-compose安装从github下载Release v2.2.2 · docker&#x2F;compose · GitHub\n选用2.2.2版本，其他版本自行从releases中选择下载即可\n下载完成后，上传到 /usr/local/bin 中，并重命名为docker-compose\n此时直接执行docker-compose -v会提示没有权限，需要授权\nchmod +x /usr/local/bin/docker-compose\n\n\n\n这个时候执行版本检查即可\n\n","slug":"docker","date":"2023-12-22T16:22:31.000Z","categories_index":"","tags_index":"docker","author_index":"Peilin"},{"id":"5db5c650ba4543d20cdc6decfa5600e8","title":"uniapp-start","content":"Uni-app简介：\n可以跨平台， 一套代码，多端发行。 作为一个跨平台解决方案。\n技术栈：vue.js \n有非常好的生态：\n\n支持通过npm安装第三方包\n支持微信小程序SDK\ndcloud插件市场\n\n\n","slug":"uniapp-start","date":"2023-12-21T19:11:38.000Z","categories_index":"","tags_index":"移动端","author_index":"Peilin"},{"id":"24d9916b82108a815fcb896c7754eb78","title":"Java异步编程","content":"Java实现异步编程前言在开发过程中，异步很常见。相比同步执行，异步可以提升执行效率，大大降低请求链路时间，提升用户体验。 比如在发送短信、发送邮件等业务场景中可以用到异步。\n什么是异步？通过一个例子来解释：\n假如有如下应用场景\n\n这个业务逻辑线是同步执行， 意味着 发送短信 这一步需要在赠送积分成功过后才会执行。 这就是同步执行的例子。\n实际上，发送短信和赠送积分可能没有依赖关系，可以将这两步操作同时执行，提升效率。这就是典型的异步执行。\n\n在Java中，如何异步编程本文介绍如下8种方式：\n\nThread\nFuture\n异步框架CompletableFuture\nSpring注解@Async\nSpringApplicationEvent事件\n消息队列\n其他异步框架\nGuava异步\n\nThread线程异步通过Thread实现线程异步有两种方式：\n\nextends  Thread\npublic class ThreadTest extends Thread &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n        ThreadTest threadTest = new ThreadTest();\n        threadTest.start();\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n    &#125;\n&#125;\n\n---\n输出结果：\nthread Thread[main,5,main] running \nthread Thread[Thread-0,5,main] running \n\n\n\nimplements Runnable\npublic class RunnableTest &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n        new Thread(new RunnableImpl()).start();\n    &#125;\n&#125;\n\nclass RunnableImpl implements Runnable &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n    &#125;\n&#125;\n\n其他写法\n// java8后 Lambda表达式\npublic static void main(String[] args) &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n        new Thread(\n            () -> System.out.println(\"thread \" + Thread.currentThread() +  \" running\")\n        ).start();\n&#125;\n\n// 匿名内部类\npublic static void main(String[] args) &#123;\n        System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n        new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(\"thread \" + Thread.currentThread() + \" running \");\n            &#125;\n        &#125;).start();\n&#125;\n\n以上的功能是一样的，采取合适的方式即可。\n需要注意的是，这样反复开启、销毁线程会消耗系统资源，可以使用线程池代替\n\n使用线程池实现\nprivate static final Executor executor = Executors.newCachedThreadPool();\n\npublic static void main(String[] args) &#123;\n    executor.execute(() -> &#123;\n        // do something\n    &#125;);\n&#125;\n\nFuturepublic class FutureTest &#123;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ExecutorService executorService = Executors.newFixedThreadPool(1);\n        Future&lt;String> future = executorService.submit(() -> &#123;\n            System.out.println(\"do something\");\n            return \"this is result after doing something\";\n        &#125;);\n        // 这里调用 Future.get() 会阻塞主线程\n        String res = future.get();\n        System.out.println(res);\n    &#125;\n&#125;\n\n\n\nCompletableFuturepublic class CompletableFutureTest &#123;\n\n    public static void main(String[] args) throws Exception &#123;\n        // 有返回值\n        CompletableFuture&lt;String> stringCompletableFuture = CompletableFuture.supplyAsync(() -> \t\t&#123;\n            System.out.println(Thread.currentThread().getName() + \": is running\");\n            return \"result\";\n        &#125;);\n        // 无返回值\n        CompletableFuture&lt;Void> voidCompletableFuture = CompletableFuture.runAsync(() -> &#123;\n            System.out.println(Thread.currentThread().getName() + \": is running\");\n        &#125;);\n        String res = stringCompletableFuture.get();\n        System.out.println(res);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n使用CompletableFuture可以不用显式调用线程池\nGuava异步Guava的ListenableFuture顾名思义就是可以监听的Future，是对java原生Future的扩展增强。Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果希望一旦计算完成就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。这样做，代码复杂，而且效率低下。使用「Guava ListenableFuture」可以帮检测Future是否完成，不需要再通过get()方法等待异步的计算结果，如果完成就自动调用回调函数，这样可以减少并发程序的复杂度。\nSpring  @Async注解Spring ApplicationEvent 事件实现异步消息队列","slug":"async","date":"2023-09-11T14:22:05.000Z","categories_index":"","tags_index":"Java","author_index":"Peilin"},{"id":"dd22f9d802401409d7599accbe2b4aa4","title":"ElasticSearch","content":"ElasticSearch前言版本：7.6\n全文检索引擎\nSQL查询时， 大数据情况下速度很慢，在加索引都无法满足的情况下，可以选择ES作为解决方案\nLuceneLucene是一套信息检索工具jar包，不包含搜索引擎系统\n包含：\n\n索引结构\n排序功能\n搜索规则\n\nLucene和ES的关系： ES是基于Lucene做了一些封装和增强\nElasticSearch概述ES是一个开源高扩展的分布式全文搜索引擎，可以近乎实时的\n存储、检索数据； 本身扩展性很好，可以扩展到上百台服务器。ES使用java开发的Lucene作为核心实现所有的索引和搜索的功能，通过简单的 RESTful API来简化复杂的Lucene，更容易上手。\nSolr概述Solr采用java开发，基于Lucene的全文搜索服务器。Solr可以独立运行jetty, tomcat等web容器中。提供了WebService API\nES和Solr的差别从性能上：\n\n对单纯已有数据进行搜索时，solr更快\n当实时建立索引时，solr会产生IO阻塞，查询性能较差\n随着数据量的增加，solr的搜索效率会变低，而es变化不大\n\n从功能上：\n\nes基本是开箱即用\nsolr利用zookeeper进行分布式管理，而es自带分布式协调管理功能\nsolr支持多格式数据如 JSON&#x2F;XML&#x2F;CSV，而es只支持JSON\n\n\n\n\n\n\n\n\n\n\nQ: 如何选择ES和Solr\nA: 无论是从性能还是从功能上，ES都是更好的选择\n安装ElasticSearch7.6版本 JDK最低要求1.8\n官网下载 [ElasticSearch]Download Elasticsearch | Elastic\n\n\n\n\n\n\n\n\n\nwindows下安装\n\n下载压缩包解压到目标文件夹\n\n目录结构\nbin 可执行文件等\nconfig 配置文件\n\t- log4j2.properties 日志配置\n\t- jvm.options jvm参数，需要配置运行内存，默认1GB运存\n\t- elasticsearch.yml es的配置文件\n\t\nlib  相关jar包\nmodules 功能模块\nplugins 插件  ik分词器等插件\nlogs  日志\n\n\n\n使用 windows下 执行 bin\\elasticsearch.bat\n\n访问测试， 默认端口9200，访问 http://localhost:9200\n\n\nElasticSearch Head可视化\n\n\n\n\n\n\n\n\nelasticsearch-head\n下载地址：GitHub - mobz&#x2F;elasticsearch-head: A web front end for an elastic search cluster\n是一个开源前端web工程，详细的可以直接看github上的文档，这里做下简单介绍\n需要nodejs\n\n克隆仓库到本地\n\ngit clone https://github.com/mobz/elasticsearch-head\n\n\n安装依赖\n\nnpm i\n\n\n启动\n\nnpm run start\n\n\n访问  http://localhost:9100\n直接打开会有跨域问题，这时需要配置一下，在elasticsearch.yml中加入以下配置\n\n\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n\n重启elasticsearch即可\nKibana针对ES开源分析的可视化平台，用于搜索、查看、管理ES中的数据。\nKibana：数据的探索、可视化和分析 | Elastic\nPs：  Kibana的版本和ES要一致\n\n下载7.6版本的Kibana，windows下解压即可\n\n汉化\n配置kibana.yml，添加配置i18n: &quot;zh-CN&quot;\n\n\nES核心概念物理设计es在后台把每个索引划分成多个分片，每份分片可以在集群中的不同服务器之间迁移。\n一个集群至少有一个节点，而一个节点就是一个es进程，节点可以有多个索引。 在创建索引时，索引会有5个默认分片（也称主分片），每一个主分片又会有一个副本（也称复制分片）\n\n如图是一个有3个节点的集群，可以看到主分片和对应的复制分片不会都在同一个节点上，这样可以保证数据不会丢失。 \n一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使es在不扫描全部文档的清空下，就能告诉哪些文档包含特定的关键字。\n\n\n\n\n\n\n\n\n\n倒排索引\n倒排索引适用于快速的全文搜索，一个索引由文档中所不重复的列表构成，对于每一个词都由一个包含它的文档列表\n如有以下两个文档\nGood good study, day day up  # 文档1 doc_1\nDay day up, good good study  # 文档2 doc_2\n\n为创建倒排索引，会将每个文档拆分为独立的词（也称词条或tokens)，然后创建一个没有重复词条的排序列表，列出每个词条出现在哪个文档：\n\n\n\n词条\ndoc_1\ndoc_2\n\n\n\nGood\n√\n×\n\n\nDay\n×\n√\n\n\ngood\n√\n√\n\n\nday\n√\n√\n\n\nstudy\n√\n√\n\n\nup\n√\n√\n\n\n倘若此时查找good词条， 文档1只命中1次， 文档2则命中2次，文档2的权重更高。\n总的来说，一个ES的索引（库）是由多个Lucene倒排索引构成\n逻辑设计ES是面向文档 （一个JSON对象），和关系型数据库有如下的对比关系：\n\n\n\n关系型数据库\nElasticSearch\n\n\n\n数据库(database)\n索引 (indices)\n\n\n表(tables)\n类型 (types) (8.x.x版本以上已经弃用)\n\n\n行(rows)\n文档 (documents)\n\n\n字段(columns)\n属性 (fields)\n\n\n\n文档\nes是面向文档的，意味着索引和搜索数据的最小单位是文档，其中，文档有一些重要属性\n\n自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key : value\n可以是层次型的，文档中包含其他文档\n灵活的结构，不依赖于预先定义的模式\n\n\n类型\n每个field都会有对应的类型，可以提前设置，也可以不设置，es会自动去匹配类型，但也有可能匹配错误。\n\n索引\n对应 数据库(database) ，es中的索引是一个很大的文档集合\n\n\n插件IK分词器分词：把一段文本划分为一个个的关键字，默认的中文分词器是一个汉字分一个词，（如：面向生活，会拆分为“面” “向” “生” “活”）这显然不符合汉语要求。\n使用IK分词器可以解决这个问题\n下载链接：[IK分词器][[GitHub - medcl&#x2F;elasticsearch-analysis-ik: The IK Analysis plugin integrates Lucene IK analyzer into elasticsearch, support customized dictionary.]\n\n下载.zip包到ES的plugins目录下解压。\n重启es\n通过elasticsearch-plugin 命令查看加载成功的插件\n\n测试：\n打开Kibana -&gt; 开发工具进行测试‘\n\n最简分词\n\nGET _analyze\n&#123;\n  \"analyzer\": \"ik_smart\",  // ik分词器， 最简拆分\n  \"text\": \"面向生活编程\"\n&#125;\n\n\n得到结果\n&#123;\n  \"tokens\" : [\n    &#123;\n      \"token\" : \"面向\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    &#125;,\n    &#123;\n      \"token\" : \"生活\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    &#125;,\n    &#123;\n      \"token\" : \"编程\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    &#125;\n  ]\n&#125;\n\n\n最细分词\n\nGET _analyze\n&#123;\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"面向生活编程\"\n&#125;\n\n​\t得到结果\n  \"tokens\" : [\n    &#123;\n      \"token\" : \"面向\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    &#125;,\n    &#123;\n      \"token\" : \"生活\",\n      \"start_offset\" : 2,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    &#125;,\n    &#123;\n      \"token\" : \"编程\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 6,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    &#125;\n  ]\n&#125;\n\n\n\n意外情况： 一些无法识别的汉语词汇需要自己加到分词器词典里面，否则就按照汉字逐一拆分\n\n在ik分词器插件的config文件中可以配置词典文件\n新建一个文件 my.dic ;\n在./config/IKAnalyzer.cfg.xml中指定该文件如下：\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n&lt;properties>\n\t&lt;comment>IK Analyzer 扩展配置&lt;/comment>\n\t&lt;!--用户可以在这里配置自己的扩展字典 -->\n\t&lt;entry key=\"ext_dict\">my.dic&lt;/entry>\n\t &lt;!--用户可以在这里配置自己的扩展停止词字典-->\n\t&lt;entry key=\"ext_stopwords\">&lt;/entry>\n\t&lt;!--用户可以在这里配置远程扩展字典 -->\n\t&lt;!-- &lt;entry key=\"remote_ext_dict\">words_location&lt;/entry> -->\n\t&lt;!--用户可以在这里配置远程扩展停止词字典-->\n\t&lt;!-- &lt;entry key=\"remote_ext_stopwords\">words_location&lt;/entry> -->\n&lt;/properties>\n\n\n此时可以在my.dic文件中添加一些自定义的词汇，再重启ES，分词时就能识别到自定义的词汇。\n如在my.dic中添加一些网络热词\n躺平\n摆烂\n摸鱼\n\n再进行分词如下：\nGET _analyze\n&#123;\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"我要摸鱼，不让摸鱼我就躺平，不让躺平我就摆烂\"\n&#125;\n\n\n\n\nRESTful风格操作基本操作\n\n\n\n\n\n\n\n\n新增\n创建索引\nPUT &#x2F;索引名称&#x2F;类型名&#x2F;文档id\n&#123;&#125;\n\n如\nPUT /peilin/t0/1\n&#123;\n\t\"name\": \"peilin1\"\n\t\"age\": \"20\"\n&#125;\n\n此时创建了索引 peilin ，再往peilin中添加了类型为 t0 id为 1的文档\n创建具体索引规则\nPUT /peilin2\n&#123;\n\t\"mappings\": &#123;\n\t\t\"properties\": &#123;\n            \"name\": &#123;\n                \"type\": \"text\"\n            &#125;,\n           \t\"age\": &#123;\n                \"type\": \"long\"\n            &#125;\n        &#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n查询\n上述已经添加了部分用例， 可以进行简单的查询\n","slug":"elasticsearch","date":"2023-09-11T14:22:05.000Z","categories_index":"","tags_index":"中间件,NoSQL","author_index":"Peilin"},{"id":"87a20f152595f7bf883ebf6f1ddb89ed","title":"SpringBoot Test单元测试","content":"不要忽视任何一个小的BUG，这将可能带来灾难\n\n\n\n\n前言单元测试的必要性在工作中有时候会问同事关于单元测试，得到如下回答：\n\n感觉项目挺赶工期的，就算想也没有时间写单元测试\n项目业务简单，感觉没有写单元测试的必要\n不知道如何写单元测试，还不如就直接调用接口测试\n公司有专业测试人员，到时候让他们测就行了\n\n这其实是对单元测试的一个误解。 单元测试可以反应出代码的水平，坚持编写单元测试可以在不经意间提高代码设计能力。 编写单元测试更是可以提升代码拆分、抽象的能力，让编程者写出更加优雅的代码。但这需要花费时间。\n不得不承认的是，大多开发人员往往迫于项目进度压力，即使想编写单元测试，也是没有时间。对于一些开发完就很少维护的项目，开发完成即交付，单元测试的意义和价值确实不太大。这其实反映了公司管理层面的问题，当然这也要求开发者在有限的时间里，提升开发效率。\n单元测试能够帮助我们在项目初期就发现和规避问题，排除一些隐藏bug，在新项目中推广和编写单元测试是非常有必要的。单元测试可以帮助我们降低测试成本和维护成本。\nJava单元测试工具在Java中有非常多的单元测试的工具或框架可供选择：\n\nJUnit：Java中最有名、使用最广泛的单元测试框架\n\nSpring Test: 使用 Spring Test 来对Spring相关的项目做单元测试，其中会结合或者集成其他测试框架和工具\n\nspring-boot-starter-test: SpringBoot项目中的单元测试\n\n\n本文选择使用 spring-boot-starter-test\nSpringBoot 2.x Test创建SpringBoot 2.7.13项目首先创建一个自己的SpringBoot 2.x项目，添加如下依赖：\n\nSpring Web\nMyBatis Plus\nLombok\n\n创建好工程后，在pom.xml里面可以看到项目自动引入了spring-boot-starter-test 依赖，这说明官方也是推荐项目使用单元测试。\n添加依赖pom.xml中依赖如下\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>com.alibaba&lt;/groupId>\n        &lt;artifactId>druid-spring-boot-starter&lt;/artifactId>\n        &lt;version>1.2.12&lt;/version>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>com.mysql&lt;/groupId>\n        &lt;artifactId>mysql-connector-j&lt;/artifactId>\n        &lt;scope>runtime&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.projectlombok&lt;/groupId>\n        &lt;artifactId>lombok&lt;/artifactId>\n        &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n        &lt;scope>test&lt;/scope>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>com.baomidou&lt;/groupId>\n        &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n        &lt;version>3.5.2&lt;/version>\n    &lt;/dependency>\n&lt;/dependencies>\n\n\n\n添加配置新增 application.yml 配置文件，在文件中添加配置如下：\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: your-db-url\n    username: your-db-username\n    password: your-db-password\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      validation-query: SELECT 1\n\nserver:\n  port: 11000\n\nmybatis-plus:\n  # 对应的 XML 文件位置\n  mapper-locations: classpath*:mapper/**/*Mapper.xml\n  configuration:\n    # 更详细的日志输出 会有性能损耗 org.apache.ibatis.logging.stdout.StdOutImpl\n    # 关闭日志记录 (可单纯使用 p6spy 分析) org.apache.ibatis.logging.nologging.NoLoggingImpl\n    # 默认日志输出 org.apache.ibatis.logging.slf4j.Slf4jImpl\n    log-impl: org.apache.ibatis.logging.nologging.NoLoggingImpl\n    # NONE：不启用 PARTIAL：只对非嵌套 resultMap 自动映射 FULL：对所有 resultMap 自动映射\n    auto-mapping-behavior: full\n    # MyBatis 自动映射时未知列或未知属性处理策\n    # NONE：不做处理 WARNING：打印相关警告 FAILING：抛出异常和详细信息\n    auto-mapping-unknown-column-behavior: none\n    map-underscore-to-camel-case: true\n  global-config:\n    # 是否打印 Logo banner\n    banner: true\n    db-config:\n      # AUTO 自增 NONE 空 INPUT 用户输入 ASSIGN_ID 雪花 ASSIGN_UUID 唯一 UUID\n      id-type: auto\n\n\n\n配置添加完成后，启动项目即可。\n准备数据库、表这里创建一个用户表进行演示\nCREATE TABLE `user` (\n  `id` int NOT NULL AUTO_INCREMENT,\n  `username` varchar(36) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '用户名',\n  `nickname` varchar(36) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '昵称',\n  `raw_password` varchar(36) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '明文密码',\n  `sign` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '个人签名',\n  `status` tinyint DEFAULT NULL COMMENT '用户状态， 1：正常， 0：冻结',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;\n\n-- 新增两条数据\nINSERT INTO `test`.`user`(`id`, `username`, `nickname`, `raw_password`, `sign`, `status`) VALUES (1, 'mainac', 'pp', '123', 'Life Oriented Programming', 1);\nINSERT INTO `test`.`user`(`id`, `username`, `nickname`, `raw_password`, `sign`, `status`) VALUES (2, 'wyd', 'dd', '234', 'MAGA', 2);\n\n\n创建对应的Service、Mapper、Entity。 可以使用Mybatis Plus代码生成器，这里不过多介绍。\n\n实体类：\n\npackage me.wpl.springboottest.business.entity;\n\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport lombok.Data;\n\n@Data\n@TableName(\"user\")\npublic class User &#123;\n\n    @TableId(type = IdType.AUTO)\n    private Integer id;\n    private String username;\n    private String nickname;\n    private String rawPassword;\n    private String sign;\n\tprivate Integer status;\n    \n&#125;\n\n\n\n\n\n\n示例单元测试DAO&#x2F;Mapper层​\t实际开发中，若采用了ORM框架，可以将DAO层视为功能的最小单元，从DAO层开始进行单元测试是有必要的。这里无视MybatisPlus自带的方法，提供一个示例查询\n\nUserMapper.java\n\npackage me.wpl.springboottest.business.mapper;\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport me.wpl.springboottest.business.entity.User;\nimport org.apache.ibatis.annotations.Mapper;\n\n@Mapper\npublic interface UserMapper extends BaseMapper&lt;User> &#123;\n    \n    @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\")\n    User getById(@Param(\"id\") Integer id);\n&#125;\n\n\n测试类\n\n分别测试查询到数据和未查询到数据的结果\npackage me.wpl.springboottest;\n\nimport me.wpl.springboottest.business.entity.User;\nimport me.wpl.springboottest.business.mapper.UserMapper;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n\n@SpringBootTest\nclass UserMapperTest &#123;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    void testSelectNonNull() &#123;\n        User user = userMapper.getById(1);\n        Assertions.assertNotNull(user);\n    &#125;\n\n    @Test\n    void testSelectNull() &#123;\n        User user = userMapper.getById(-1);\n        Assertions.assertNull(user);\n    &#125;\n&#125;\n\n\n每一个@Test对应方法都是一个单元测试，每个单元测试的情景都需要执行不报错。\n单元测试Service层实际开发中，Service层往往会依赖DAO层的一些方法， 如果DAO层方法单元测试通过了，那么在Service层就可以放心去使用，这时候只需关心Service层的代码是否出现bug。\n\nUserService &amp; Impl\n\npackage me.wpl.springboottest.business.service;\n\nimport com.baomidou.mybatisplus.extension.service.IService;\nimport me.wpl.springboottest.business.entity.User;\n\npublic interface IUserService extends IService&lt;User> &#123;\n    \n    User getById(Integer id);\n&#125;\n\n\npackage me.wpl.springboottest.business.service.impl;\n\nimport com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;\nimport me.wpl.springboottest.business.entity.User;\nimport me.wpl.springboottest.business.mapper.UserMapper;\nimport me.wpl.springboottest.business.service.IUserService;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class UserServiceImpl extends ServiceImpl&lt;UserMapper, User> implements IUserService &#123;\n    \n    @Override\n    public User getById(Integer id) &#123;\n        if (id &lt; 0) &#123;\n            throw new IllegalArgumentException(\"非法id\");\n        &#125;\n        // 其他处理逻辑\n        return baseMapper.getById(id);\n    &#125;\n    \n&#125;\n\n\n\n\n测试类\n\npackage me.wpl.springboottest;\n\nimport me.wpl.springboottest.business.entity.User;\nimport me.wpl.springboottest.business.service.IUserService;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.boot.test.context.SpringBootTest;\n\nimport javax.annotation.Resource;\n\n\n@SpringBootTest(classes = SpringbootTestApplication.class)\npublic class UserServiceTest &#123;\n\n    @Autowired\n    private IUserService userService;\n\n    // 传参正确且查到数据\n    @Test\n    public void testSelectNonNull() &#123;\n        User user = userService.getById(1);\n        Assertions.assertNotNull(user);\n    &#125;\n\t\n    // 传参正确但查不到数据的情况\n    @Test\n    public void testSelectNull() &#123;\n        User user = userService.getById(10000);\n        Assertions.assertNull(user);\n    &#125;\n\t\n    // 测试错误传参的情况\n    @Test\n    public void testIllegalArgs() &#123;\n        Assertions.assertThrows(IllegalArgumentException.class, () -> userService.getById(-1));\n    &#125;\n\n&#125;\n\n\n\n\n单元测试Controller层\nUserController\n\npackage me.wpl.springboottest.business.controller;\n\nimport lombok.RequiredArgsConstructor;\nimport me.wpl.springboottest.business.entity.User;\nimport me.wpl.springboottest.business.service.IUserService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.Objects;\n\n\n@RestController\n@RequestMapping(\"/api/v1/user\")\n@RequiredArgsConstructor\npublic class UserController &#123;\n\n    private final IUserService userService;\n\n    @GetMapping(\"/&#123;id&#125;\")\n    public ResponseEntity&lt;User> getById(@PathVariable(\"id\") Integer id) &#123;\n        return ResponseEntity.ok(userService.getById(id));\n    &#125;\n\n&#125;\n\n\n测试类\n\npackage me.wpl.springboottest;\n\nimport me.wpl.springboottest.business.controller.UserController;\nimport me.wpl.springboottest.business.entity.User;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.http.ResponseEntity;\n\nimport javax.annotation.Resource;\n\n@SpringBootTest\npublic class UserControllerTest &#123;\n\n    @Resource\n    private UserController userController;\n\n    @Test\n    public void testGetUser() throws Exception &#123;\n        ResponseEntity&lt;User> responseEntity = userController.getById(1);\n        Assertions.assertTrue(responseEntity.getStatusCode().is2xxSuccessful());\n        Assertions.assertNotNull(responseEntity.getBody());\n    &#125;\n&#125;\n\n这里说明一下，单元测试针对最小功能点，Controller层同样作为SpringBean，直接进行Bean的方法测试即可。要通过Http测试接口，那么方法可就多了：\n\n使用Postman、ApiFox等接口调式工具\n另起一个单元测试类，通过HttpClient、RestTemplate等方式进行调用测试\n通过MockMvc\n\n总结以上就是使用SpringBoot Test进行单元测试的全部介绍。\n另外需要注意的是，如果编写了SpringBoot Test，在执行Maven的命令 mvn complie &#x2F; mvn packge等命令的时候会执行项目中的单元测试，全部测试通过才会进行后续的mvn命令。 通过单元测试减少打包上线后出现问题的概率。\n\nBy Peilin,\nLife Oriented Programming\n","slug":"springboot-test","date":"2023-07-18T09:34:12.000Z","categories_index":"","tags_index":"Java,SpringBoot,单元测试","author_index":"Peilin"},{"id":"d696be916da802ad82e97dd238415af6","title":"Java实现树形接口","content":"Java实现树形接口前言做后端开发，遇到树形结构的情况可以说是非常多。菜单、部门机构等都会用到。 这种经常遇见且通用的功能无需针对每个业务去写冗余代码，本文就介绍一下如何实现一个通用的树形结构，将集合树形化。\n注：JDK版本需要在1.8以上\n思想\n在关系型数据库表中实现树形父子级关系，通常是取一个字段存父结点的id。\n在代码中则是在数据结构中定义当前结点id、父级id 和当前结点的子结点集合。\n只需要知道当前结点的id，父结点id，当前结点的子结点集合，就可以使用递归（Recursion）进行树形构造。\n\n代码接口import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * &lt;T> your pojo class\n * 树形结构工具， pojo类实现 TreeNode 即可\n */\npublic interface TreeNode&lt;T extends TreeNode&lt;T>> &#123;\n\n    Integer getId();\n\n    Integer getParentId();\n\n    List&lt;T> getChildren();\n\n    void setChildren(List&lt;T> children);\n\n    /**\n     * 递归构建树。\n     * @param root 当前根结点\n     * @param list 待遍历的结点\n     */\n    default void recursion(T root, List&lt;T> list) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        for (T n : list) &#123;\n            if (n.getParentId() != null &amp;&amp; n.getParentId().equals(root.getId())) &#123;\n                if (root.getChildren() == null) &#123;\n                    root.setChildren(new ArrayList&lt;>());\n                &#125;\n                root.getChildren().add(n);\n                n.recursion(n, list);\n            &#125;\n        &#125;\n    &#125;\n\n    /**\n     * 将传入的 list 树形化\n     * @return 根节点集合\n     */\n    static &lt;T extends TreeNode&lt;T>> List&lt;T> treeify(List&lt;T> list) &#123;\n        // 筛出根结点, 这里定义parentId为null的结点为根结点\n        List&lt;T> roots = list.stream().filter(x -> x.getParentId() == null).collect(Collectors.toList());\n        roots.forEach(x -> x.recursion(x, list));\n        return roots;\n    &#125;\n\n&#125;\n\n\n\n\n实现&#x2F;示例\n实现\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n// 模拟部门数据\n@Data\n@AllArgsContructor\npublic class DeptDTO implements TreeNode&lt;DeptDTO> &#123;\n    private Integer id;\n    private Integer parentId;\n    private List&lt;DeptDTO> children;\n\t\n    // other fields\n\t\n&#125;\n\n Tips: 这里DeptDTO实现了TreeNode接口，需要实现接口的方法； 接口的定义与lombok生成的getter &#x2F; setter正好对应。 做到了一句多的代码也不写！  当然了，如果你的字段名称与接口不同，实现一下就行了， 如下\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Menu implements TreeNode&lt;Menu> &#123;\n    private Integer menuId;\n    private Integer parentId;\n    private List&lt;Menu> subMenus;\n\t\n    private String menuName;\n    // other fields\n\t\n    @Override\n    public Integer getId() &#123;\n        return this.menuId;\n    &#125;\n    \n    @Override\n    public Integer getParentId() &#123;\n        return this.parentId;\n    &#125;\n    \n    @Override\n    public List&lt;Menu> getChildren() &#123;\n        return this.subMenus;\n    &#125;\n    \n    @Override\n    public void setChildren(List&lt;Menu> children) &#123;\n        this.subMenus = children;\n    &#125;\n&#125;\n\n\n测试调用\n\npublic class TestTreeNode &#123;\n    public void testTreeify() &#123;\n        List&lt;DeptDTO> nodes = new ArrayList&lt;>();\n        nodes.add(new DeptDTO(1, null, null));\n        nodes.add(new DeptDTO(2, 1, null));\n        nodes.add(new DeptDTO(3, 1, null));\n        nodes.add(new DeptDTO(4, 2, null));\n        nodes.add(new DeptDTO(5, 2, null));\n        List&lt;DeptDTO> roots = TreeNode.treeify(nodes);\n    &#125;\n&#125;\n\n\n\n\n\n总结通过将自己的业务中的pojo类实现TreeNode， 指定出该类的id 、 parentId、子集合，即可便捷使用\n\nLife Oriented Programming\n","slug":"java-tree-node","date":"2023-07-05T16:33:32.000Z","categories_index":"","tags_index":"Java,后端,技巧分享","author_index":"Peilin"},{"id":"00c071c4589539354f157ade6456752e","title":"vue-dragbox 叠层拖动框","content":"vue dragbox - 拖动框前言在工作中，遇到这样一个需求： 甲方老板需要系统内的所有弹窗做成类似windows桌面那样， 可以拖动且按层级展示。\n那本文就用vue来实现一个通用的拖动框组件。\n思想要实现这个功能，可以分为以下几步：\n\n拖动\n改变元素的x , y定位， 可以联想到使用css中的 transform : translate() ； \n拖动可以拆解为3个动作：\n\n鼠标按下 mousedown\n鼠标拖动 mousemove\n鼠标弹起 mouseup\n\n\n层级\n点击某个弹窗，将该弹窗的zIndex设置为比当前zIndex更大即可； 如果是用的element-ui， 可以使用 PopupManager.js 实现层级管理\n\n组件封装\n使用插槽的方式，将弹窗内容包含在该组件里面\n\n\n代码实现&lt;template&gt;\n  &lt;div\n    class&#x3D;&quot;draggable-box&quot;\n    :class&#x3D;&quot;draggable?&#39;cursorM&#39;:&#39;&#39;&quot;\n    :style&#x3D;&quot;&#123;\n      width: &#96;$&#123;width&#125;px&#96;,\n      height: &#96;$&#123;height&#125;px&#96;,\n      backgroundColor: background,\n      transform: &#96;translate($&#123;x&#125;px, $&#123;y&#125;px)&#96;,\n      zIndex: zIndex,\n    &#125;&quot;\n    @mousedown.prevent&#x3D;&quot;dragStart&quot;\n    @mousemove.prevent&#x3D;&quot;drag&quot;\n    @mouseup.prevent&#x3D;&quot;dragEnd&quot;\n  &gt;\n    &lt;slot&gt;&lt;&#x2F;slot&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n  import &#123; PopupManager &#125; from &#39;element-ui&#x2F;lib&#x2F;utils&#x2F;popup&#39;;\n\n  export default &#123;\n    name: &#39;DraggableBox&#39;,\n    props: &#123;\n      x: &#123;\n        type: Number,\n        default: 0,\n      &#125;,\n      y: &#123;\n        type: Number,\n        default: 0,\n      &#125;,\n      width: &#123;\n        type: Number,\n        default: 5120,\n      &#125;,\n      height: &#123;\n        type: Number,\n        default: 0,\n      &#125;,\n      background: &#123;\n        type: String,\n        default: &#39;transparent&#39;,\n      &#125;,\n      zIndex: &#123;\n        type: Number,\n        &#x2F;&#x2F; 默认为当前层级+100\n        default: PopupManager.nextZIndex() + 100,\n      &#125;,\n      draggable: &#123;\n        type: Boolean,\n        default: true\n      &#125;\n    &#125;,\n    data() &#123;\n      return &#123;\n        isDragging: false,\n        startPosition: &#123; x: 0, y: 0 &#125;,\n      &#125;\n    &#125;,\n    methods: &#123;\n      &#x2F;&#x2F; 开始拖动\n      dragStart(event) &#123;\n        if(this.draggable)&#123;\n          this.isDragging &#x3D; true\n          this.startPosition.x &#x3D; event.clientX - this.x\n          this.startPosition.y &#x3D; event.clientY - this.y\n          &#x2F;&#x2F; 开始拖动时，将当前zIndex设置为最大，实现弹窗层级\n          this.zIndex &#x3D; PopupManager.nextZIndex();\n        &#125;\n      &#125;,\n      &#x2F;&#x2F; 拖动中改变 x,y\n      drag(event) &#123;\n        if(this.draggable) &#123;\n          if (!this.isDragging) return\n          this.x &#x3D; event.clientX - this.startPosition.x\n          this.y &#x3D; event.clientY - this.startPosition.y\n        &#125;\n      &#125;,\n      &#x2F;&#x2F; 拖动结束\n      dragEnd() &#123;\n        this.isDragging &#x3D; false\n      &#125;,\n    &#125;,\n  &#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n  .cursorM&#123;\n    cursor: move;\n\n  &#125;\n  .draggable-box &#123;\n    position: absolute;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n示例&lt;template&gt;\n\t&lt;DragBox&gt;\n        &lt;!-- 在此处定义你的对话框内容 --&gt;\n    \t&lt;div class&#x3D;&quot;dialog&quot;&gt;\n    \t\tLife Oriented Programming\n    \t&lt;&#x2F;div&gt;\n    &lt;&#x2F;DragBox&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; 换成自己的项目路径\nimport DragBox from &#39;@&#x2F;components&#x2F;Dragbox&#39;;\n    \nexport default &#123;\n    name: &#39;mytest&#39;,\n    components: &#123;DragBox&#125;,\n    data() &#123;\n        return &#123;\n            \n        &#125;\n    &#125;\n&#125;\n\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n    .dialog &#123;\n        position: absolute;\n        width: 1000px;\n        height: 500px;\n        border: 1px solid #FFF;\n    &#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n以上就是使用vue实现拖动框组件的内容。\nLife Oriented Programming\n","slug":"vue-dragbox","date":"2023-07-05T16:27:23.000Z","categories_index":"","tags_index":"Vue.js,前端","author_index":"Peilin"},{"id":"bb404c7dbd8eec4e7c8b388c731f8864","title":"nvm","content":"前言在使用Hexo搭建博客时，推荐安装16.x以上版本的nodejs。 但是自己电脑工作时所用的node版本是14.x， 如果为了搭建博客又去安装其他版本的node，需要手动去切换环境变量。 切换来回避免不了麻烦甚至出错，于是想着有没有一个更加好的解决方案。   \n这就是本文要介绍的 NVM (Node enVironment Manager) —— 一个node环境管理工具。\n\nNVM安装windows用户\n安装\nwindows用户可以通过 Releases nvm-windows下载 setup.exe 进行安装\n\n\n\n进入上路链接github仓库， 找到 v1.1.11 下的 Assets， 找到 nvm-setup.exe 下载\n\n双击启动 .exe 进行安装\n\n选择nvm 的安装路径\n\n选择node的安装路径\n\n打开控制台，输入 nvm -v 如果正确展示版本表示安装成功\n\n\n注意：两者路径都可以自定义，一定不要带中文（大部分开发软件都是如此）\nlinux用户\n安装\n\n使用curl 或者 wget\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash\n\n安装脚本运行后，会在您的主目录下创建一个 .nvm 文件夹，并在您的 shell 配置文件（例如 .bashrc、.zshrc 或 .profile）中添加必要的配置。\n\n执行 nvm --version 查看安装情况\n\n\n\n\n\nNVM使用接下来介绍NVM的一些常用指令\n查看版本# 查看nvm版本\nnvm -v \n# 查看目前（已安装）可用的node版本\nnvm list \n\n# 查看可安装的node版本\nnvm list available \n\n\n\nnode 安装&#x2F;卸载安装\n# 使用nvm安装指定版本的nodejs\nnvm install &lt;node version> \n\n# 安装16.14.0 版本的nodejs\nnvm install 16.14.0 \n\n# 使用nvm安装稳定版nodejs\nnvm install stable\n\n\n\n卸载\n# 指定卸载版本\nnvm uninstall &lt;version> \n\n# 指定卸载16.14.0版本的nodejs\nnvm unistall 16.14.0 \n\n\n\nnode 版本切换# 指定node版本为当前node环境\nnvm use &lt;node version>\n\n# 指定使用 16.14.0的node版本\nnvm use 16.14.0 \n\n# 指定默认版本\nnvm alias default &lt;version> \n\n\n\n示例# 安装完成后执行\nnvm -v\n>> \n1.1.10\n\n# 查看可安装的node版本\nnvm list available\n>> \n|   CURRENT    |     LTS      |  OLD STABLE  | OLD UNSTABLE |\n|--------------|--------------|--------------|--------------|\n|    20.3.1    |   18.16.1    |   0.12.18    |   0.11.16    |\n|    20.3.0    |   18.16.0    |   0.12.17    |   0.11.15    |\n|    20.2.0    |   18.15.0    |   0.12.16    |   0.11.14    |\n|    20.1.0    |   18.14.2    |   0.12.15    |   0.11.13    |\n|    20.0.0    |   18.14.1    |   0.12.14    |   0.11.12    |\n|    19.9.0    |   18.14.0    |   0.12.13    |   0.11.11    |\n|    19.8.1    |   18.13.0    |   0.12.12    |   0.11.10    |\n|    19.8.0    |   18.12.1    |   0.12.11    |    0.11.9    |\n|    19.7.0    |   18.12.0    |   0.12.10    |    0.11.8    |\n|    19.6.1    |   16.20.1    |    0.12.9    |    0.11.7    |\n|    19.6.0    |   16.20.0    |    0.12.8    |    0.11.6    |\n|    19.5.0    |   16.19.1    |    0.12.7    |    0.11.5    |\n|    19.4.0    |   16.19.0    |    0.12.6    |    0.11.4    |\n|    19.3.0    |   16.18.1    |    0.12.5    |    0.11.3    |\n|    19.2.0    |   16.18.0    |    0.12.4    |    0.11.2    |\n|    19.1.0    |   16.17.1    |    0.12.3    |    0.11.1    |\n|    19.0.1    |   16.17.0    |    0.12.2    |    0.11.0    |\n|    19.0.0    |   16.16.0    |    0.12.1    |    0.9.12    |\n|   18.11.0    |   16.15.1    |    0.12.0    |    0.9.11    |\n|   18.10.0    |   16.15.0    |   0.10.48    |    0.9.10    |\n\nThis is a partial list. For a complete list, visit https://nodejs.org/en/download/releases\n\n# 从上面选择一个你需要的版本安装\nnvm install 16.14.0\nnvm install 14.13.3\n\n# 安装成功后， nvm list 查看已安装版本\nnvm list\n>>\n  16.14.0\n* 14.15.3 (Currently using 64-bit executable)\n\n# 切换node版本\nnvm use 16.14.0\n>>\n  Now using node 16.14.0（64 bit）\n  \n# 验证是否切换成功\nnode -v\nnpm -v\n\n这样就可以实现node版本控制了。 \n最后需要注意的是，此时只是切换了系统中的node环境变量，此时你的开发编辑器中的需要 手动切换 一下。 \nnvm使用 symlink 实现node版本控制， 在安装nvm的时候，会让你指定一个 symlink 的本地文件路径， 这个 symlink 会指向你当前 nvm use  版本的node根目录； 打开电脑的环境变量配置其实可以看见 NVM_SYMLINK ， 这个其实就是你的nodejs环境变量，只不过是由nvm进行管理的。\nsymlink - 符号链接，属于软连接\n只需要在编辑器中设置 NVM_SYMLINK 指向的路径即可， 如我的路径是 C:\\Program Files\\nodejs \n\n以上。\nBy Peilin\n— Life Oriented Programming —\n","slug":"nvm","date":"2023-06-23T22:59:01.000Z","categories_index":"","tags_index":"Node.js,开发环境管理","author_index":"Peilin"},{"id":"60483de8f62e71e12cab19b058a7262d","title":"Markdown学习","content":"Markdown 学习背景无论是使用Hexo、Hugo或是Jekyll搭建自己的博客写博文，还是用来编写文档，markdown语法的使用必不可少。 在本地可以下载 Typora — 一款支持markdown(md) 语法的编辑器， 可以更快速、更效率的编写md文档，这里就不过多介绍。  但如果是想在github 直接进行文档编写，那最好是要熟悉一下md语法。\n另外，如果需要编写docx \\ pdf 文档， 也可以使用markdown， 在编写完成后用插件转换即可。\n以下是正题\n\n语法文本标题可以看到本文的一些标题，就是用md语法实现的\n\nTypora中快捷键  Ctrl  1 2 3 4 5 6  为对应的标题 \n\n示例代码\n\n\n# 这是一级标题\n## 这是二级标题\n### 这是三级标题\n#### 这是四级标题\n##### 这是五级标题\n###### 这是六级标题\n\n​\t当然你也可以使用html，得到的效果是一样的\n&lt;h1>这是一级标题&lt;/h1>\n&lt;h2>这是一级标题&lt;/h2>\n&lt;h3>这是一级标题&lt;/h3>\n&lt;h4>这是一级标题&lt;/h4>\n&lt;h5>这是一级标题&lt;/h5>\n&lt;h6>这是一级标题&lt;/h6>\n\n\n效果如下\n\n\n\n字体\n加粗\n\n说明：在文本两侧加 **；Typora快捷键： Ctrl  B\n\n示例代码 \n**我变粗了**\n\n\n斜体\n\n说明：在文本两侧加 *，Typora快捷键： Ctrl  I\n\n示例代码 \n*我变斜了*\n\n\n斜体加粗\n\n说明：在文本两侧加 ***\n\n示例代码 \n***我又斜又粗***\n\n\n删除\n\n说明：在文本两侧加 ~~ ；快捷键： Alt Shift 5  \n\n示例代码 \n~~我被删除了~~\n\n\n效果如下\n我变粗了\n我变斜了\n我又粗又斜\n我被删除了\n\n\n段落\n说明： 使用空格分隔一行或多行文本\n\n换行\n说明： 使用 &lt;br&gt; ，或者在结尾使用两个空格或多个空格结束一行\n\n代码单行代码\n说明 见代码\n\n代码\n使用 `` 引用起来\n如 `abc`\n\n效果\nabc\n\n\n代码块\n说明 使用 &#96;&#96;&#96; 加任意可识别的编程语言\n\n示例代码\n​```java\n\tpublic static void main(String[] args) &#123;\n\t\tSystem.out.println(\"Hello Peilin\");\n\t&#125;\n​```\n\n​```javascript\n    function hello() &#123;\n    \tconsole.log(\"Hello Peilin\")\n    &#125;\n​```\n\n\n\n效果\npublic static void main(String[] args) &#123;\n    System.out.println(\"Hello Peilin\");\n&#125;\n\nfunction hello() &#123;\n    console.log(\"Hello Peilin\")\n&#125;\n\n分割线\n说明：使用 三个以上的 - 或者 三个以上的 *\n\n代码\n***\n****\n---\n----\n\n图片\n说明\n其中 图片alt 为图片不能展示时展示的内容； url为图片的路径，可以是相对路径、绝对路径、网络路径； 图片名称为鼠标悬浮图片上展示内容\n\n代码\n![图片alt]('图片url' '图片名称')\n\n如\n\t\n![image-20230622235021158](markdown-learn/image-20230622235021158.png '皮皮猫')\n\n其中 图片alt 为图片不能展示时展示的内容； url为图片的路径，可以是相对路径、绝对路径、网络路径\n\n效果如下\n\n\n\n列表\n无序列表\n\n说明：在行首，使用 - * + 任意一个加空格 space ，接文本即可； 若想成为下一级，则在行首加Tab或者3个空格\n\n代码\n- 无序列表1\n\t- 无序列表1 子列表\n* 无序列表2\n+ 无序列表3\n\n效果\n\n\n\n\n有序列表\n\n说明：在行首 使用数字 . space 接文本即可\n\n代码\n1. 列表内容\n2. 列表内容\n3. 列表内容\n\n效果\n\n列表内容\n列表内容\n列表内容\n\n\n\n\n\n表格\n说明： 直接见代码\n\n代码\nname | age | gender\n--|:--:|--:\npipi | 4 | male\nhanhan | 2 | male\n\n:-- 左对齐\n--: 右对齐\n:--: 居中对齐\n\n效果\n\n\n\nname\nage\ngender\n\n\n\npipi\n4\nmale\n\n\nhanhan\n2\nmale\n\n\n\n\n链接\n代码\n[名称](地址)\n\n如\n\n[百度](https://www.baidu.com)\n\n百度\n\n说明\n通过上述方式创建的链接是页面内跳转。 如果想实现点击打开新标签页，则需要使用html a标签，具体代码如下\n&lt;a href=\"https://www.baidu.com\" target=\"_blank\">百度&lt;/a>\n\n百度\n\n\n转义\n说明： 在Markdown语法中有许多字符都表示着不同的功能，如果想使用原本字符，直接加 \\ 在该字符之前进行转义即可。 比如你想用 - 字符， 结果发现 - 加 空格就变成了无序列表，此时直接  \\- 即可。\n\n脚标\n代码\n\n[^标注文本]:\n\n\n效果\n\n区块\n在段落开头引用 &gt; 符号然后跟一个空格\n\n&gt; 区块引用\n&gt; Text ABC\n&gt;&gt; 使用多个 &gt; 嵌套\n\n\n效果\n\n\n\n\n\n\n\n\n\n区块引用\nText ABC\n\n\n\n\n\n\n\n\n\n\n使用多个 &gt; 嵌套\n\n\n\n\n其他在markdown中， 同样可以使用html进行替代，但就编写文档而言，markdown语法更加精炼简洁，功能上也基本够用。 当然就像链接一样，可能有的功能达不到你的需求，这时候使用html可能就能满足你的需求。   \nmarkdown转pdf &#x2F; word 可以使用typora的自带导出功能。 也可以使用Pandoc\n\n欢迎补充指正，\n以上。\nBy Peilin\n— Life Oriented Programming —\n","slug":"markdown-learn","date":"2023-06-21T17:49:14.000Z","categories_index":"","tags_index":"Markdown","author_index":"Peilin"}]